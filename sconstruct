#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import platform

import mm


class GLOBAL_VAR:
    def __init__(self, env, arch):
        self.__mm = mm.MM()
        self.env = env
        self.arch = self.__init_arch(arch)
        self.module_name = self.get_env("module.name")
        self.dep_modules = self.get_env_list('module.depend', [])
        self.libs_dir = self.get_env("env.libs_dir")
        assert self.libs_dir is not None
        self.libs_dir = os.path.join(self.libs_dir, arch)
        self.list_dep_inc = self.get_depend_module_dir()
        self.build_dir = os.path.join(self.get_env("env.build_dir"), self.module_name, arch)
        if self.build_dir is not None:
            VariantDir(self.build_dir, ".", duplicate=0)
        self.share_libs = []
        self.static_libs = []
        self.dict_targets = {}
        self.install_dir = self.get_env("module.install_dir")

        ccflags = self.get_env("module.CCFLAGS")
        self.env.Append(CCFLAGS=ccflags)
        cxxflags = self.get_env("module.CXXFLAGS")
        self.env.Append(CXXFLAGS=cxxflags)

    def install(self):
        if self.install_dir is not None:
            env.Install(self.install_dir, self.static_libs)
            env.Install(self.install_dir, self.share_libs)
            env.Alias('install', self.install_dir)

    def default_target(self):
        self.env.Default(self.share_libs)
        self.env.Default(self.static_libs)

    def get_env_list(self, env_name, default=None):
        value = self.__mm.mm_config.get_value(env_name, None)
        if value is None:
            return default
        return value.split(',')

    def get_env(self, env_name):
        return self.__mm.mm_config.get_value(env_name, None)


    def get_module_name(self, module_node):
        name = self.get_env(module_node + '.name')
        if name is None:
            name = module_node.split('.')[-1]
        return name


    def get_depend_module_dir(self):
        inc_dir = []
        for submodule in self.dep_modules:
            node = 'module.depend.' + submodule
            dirs = self.get_env_list(node + '.inc_dir')
            if dirs is None:
                continue
            for dir in dirs:
                inc_dir.append(dir)
        return inc_dir

    def get_node_sources(self, node):
        name = self.get_module_name(node)
        sources = vars.get_env_list(node + '.sources', [])
        if 'none' in sources:
            return []
        src_dir = self.get_env(node + '.src_dir')
        if src_dir is None:
            src_dir = "src"
        print(sources)
        if 'all' in sources:
            sources = mm.find_source(self.get_env_list('env.src_suffixes'), src_dir, recursive=True)
        elif len(sources) is 0:
            sources = mm.find_source(self.get_env_list('env.src_suffixes'), src_dir)
        else:
            sources_count = len(sources)
            for index in xrange(sources_count):
                sources[index] = os.path.join(src_dir, sources[index])
        # print sources
        # print("node = %s name = %s source = %s" % (module_node, name, source))
        assert isinstance(sources, list)
        return sources

    def get_node_inc_dir(self, node):
        inc_dir = vars.get_env_list(node + ".inc_dir")
        if inc_dir is None:
            inc_dir = []
            if os.path.isdir('include'):
                inc_dir = ["include"]
        return inc_dir

    def get_node_src_dir(self, node):
        dir = vars.get_env_list(node + ".src_dir")
        if dir is None:
            if os.path.isdir('src'):
                dir = "src"
        return dir

    def list_append(self, list, item):
        if item is None:
            return
        if isinstance(item, tuple):
            for value in item:
                list.append(value)
        else:
            list.append(item)

    def build_module_node(self, module_node):
        sources = vars.get_node_sources(module_node)
        sources_count = len(sources)
        if sources_count == 0:
            return
        for index in xrange(sources_count):
            sources[index] = os.path.join(self.build_dir, sources[index])
        # print sources
        # print("node = %s name = %s source = %s" % (module_node, name, source))
        list_inc = []
        self.list_append(list_inc, self.get_node_inc_dir(module_node))
        self.list_append(list_inc, self.get_node_src_dir(module_node))
        self.list_append(list_inc, self.list_dep_inc)
        self.list_append(list_inc, self.get_env_list(module_node + ".build.inc_dir"))
        name = self.get_module_name(module_node)
        lib_name = os.path.join(self.libs_dir, name)
        sharelib = env.SharedLibrary(target=lib_name, source=sources, CPPPATH=list_inc)
        staticlib = env.StaticLibrary(target=lib_name, source=sources, CPPPATH=list_inc)
        self.share_libs.append(sharelib)
        self.static_libs.append(staticlib)
        self.dict_targets[name] = [staticlib, sharelib]

    def build_all(self):
        submodules = self.get_env_list('module.sub')
        if submodules is not None:
            for submodule in submodules:
                node = 'module.sub.' + submodule
                self.build_module_node(node)
                depend = self.get_env(node + '.depend')
                if depend is not None:
                    print("---Depend = " + depend)
                    self.env.Depends(self.dict_targets[submodule], self.dict_targets[depend])
        self.build_module_node('module')

    def __init_arch(self, arch):
        if arch is "":
            arch = platform.machine()
        arch_node = 'arch.' + arch
        env_cc = self.get_env(arch_node + ".CC")
        if env_cc is not None:
            env['CC'] = env_cc
        env_cxx = self.get_env(arch_node + ".CXX")
        if env_cxx is not None:
            env['CXX'] = env_cxx
        env_ccflags = self.get_env(arch_node + ".CCFLAGS")
        if env_ccflags is not None:
            env.Append(CCFLAGS=env_ccflags)
        env_cxxflags = self.get_env(arch_node + ".CXXFLAGS")
        if env_cxxflags is not None:
            env.Append(CXXFLAGS=env_cxxflags)
        env_shlinkflags = self.get_env(arch_node + ".SHLINKFLAGS")
        if env_shlinkflags is not None:
            env.Append(SHLINKFLAGS=env_shlinkflags)
        print('arch = ' + arch)
        return arch

    def packall(self):
        all_share_libs = []
        all_static_libs = []
        for module in self.dep_modules:
            sharelib_name = self.env['LIBPREFIX'] + module + self.env['SHLIBSUFFIX']
            all_share_libs.append(os.path.join(self.libs_dir, sharelib_name))
            static_name = env['LIBPREFIX'] + module + env['LIBSUFFIX']
            all_static_libs.append(os.path.join(self.libs_dir, static_name))

        zip_dir = os.path.join(self.build_dir, "zip")
        zip_libdir = os.path.join(zip_dir, "lib")
        env.Accumulate(zip_dir, self.list_dep_inc)
        env.Accumulate(zip_libdir, all_share_libs)
        env.Accumulate(zip_libdir, all_static_libs)
        zipall = env.Zipper(self.module_name + "_all", zip_dir)
        env.Alias('packall', zipall)


env = Environment(tools=['default', TOOL_ADD_HEADER])
env['CCCOMSTR'] = "Compiling $TARGET"
env['CXXCOMSTR'] = "Compiling $TARGET"
env['LINKCOMSTR'] = "Linking $TARGET"
# env['STATIC_AND_SHARED_OBJECTS_ARE_THE_SAME']=1
# Export('env')
arch = ARGUMENTS.get('arch', "")

vars = GLOBAL_VAR(env, arch)
vars.build_all()
vars.default_target()
vars.install()
vars.packall()


